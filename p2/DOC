NOTE: Implemented extra credit algorithm: p2fl and mck2.

Power of 2 Free List Algorithm:
utilization factor: 1.021538
We use one extra page to store the entries for each power of 2 free list.
Whenever a request comes, we round up the size and allocate the first block
in the free list. If it is empty, then a new page is allocated and splitted
into the same size blocks which will be added to the free list. When free,
if a page is made up of all free blocks after this operation, we free
the page and remove the blocks in the free lsit. Otherwise, we simply 
insert at the head of the free list.
Worst free latency happens when we free the last allocated block in the
page. Since we need to free the page, we need to remove all the free 
blocked recorded in the free list. To traverse the free list for certain
size entry, it taks O(n) where n is the size of the specific free list.
Average free latency is O(1). To free a block, since we know the size,
we can directly insert it in the beginning of the specific free list.
Amortized latency is thus O(1).
Worst alloc latency happens when the specific free list is empty, then
we need to get a new page and separate the whole page into the same size
and link them together into the free list. It takes O(m) where m is the
number of blocks we can split the page into.
Average alloc latency is O(1). To alloc a block, we can directly assign
the first block pointed by the specific free list. Amortized latency is
O(1).

MCK2:
utiliazation factor: 1.016246
We implement MCK2 in the same way as P2FL except for that instead of storing
the entry address at the beginning of each allocated block, and returning
the address after it in P2FL, what we do is diretly return the beginning 
address of the block and when the block is freed, we simply add it to the
correct free list using its round-up size.
Worst/Average free/alloc latencies are the same as P2FL mentioned above.
Because the only improvement MCK2 made is remove the first pointer used
by allocated memories to point back at the free list entry, thus makes 
requests sizing at exact power of 2 efficient. Other than that, it's the
same. 

Resource Map:
utilization factor: 0.294727
First fit is used in our implementation. Free lists are sorted in increasing 
address order. Average free/alloc latencies are O(n). When allocating, we
need to traverse the the free list to find the first buffer whose size is
larger than requested and allocate this buffer. When freeing, we need to 
traverse the free list to find the first buffer whose address is larger than 
the buffer and insert the freed buffer before that buffer. Worst case 
free/alloc latencies are O(n), because when freeing/allocating, sometimes 
we need to traver the whole list to find the target.

Buddy System:
utilization factor: 0.628560
In our implementation, the first 128 bytes of a special page are allocated
to hold the pointers to free lists of power of 2 sizes. Then the rest of the
page is split into power of two sized buffers and add them to the free list.
When freeing, we add the block to the head of the corresponding free list.
When allocating, we remove the head of the corresponding free list. Even if
coalescing and splitting are concerned, both of them takes constant time. So
the average/worst case free/alloc latencies are O(1).
